<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>packman - text file packaging utility</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>packman</h1>
        <p>text file packaging command line utility</p>
        <p class="view"><a href="https://github.com/captainbrosset/packman">View the Project on GitHub <small>captainbrosset/packman</small></a></p>
        <ul>
          <li><a href="http://search.npmjs.org/#/packman">Get from <strong>NPM</strong></a></li>
          <li><a href="https://github.com/captainbrosset/packman/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/captainbrosset/packman/tarball/master">Download <strong>TAR Ball</strong></a></li>
        </ul>
      </header>
      <section>
        <p>packman is a command line utility used to package text files together.</p>

<p>Even if packman was born of the need to group several JavaScript files together in one big, minified, versioned JavaScript file to improve websites' performance, it works with any type of text files and can package any number of files in any number of crazy ways you want.</p>

<h1>Installation</h1>

<p>packman can be installed via npm, so first, get <a href="http://nodejs.org">nodejs</a> installed. Then type:</p>

<pre><code>npm install -g packman</code></pre>

<h1>Usage</h1>

<pre><code>packman

Options:
  -c, --config   Path to the config file to use (defaults to .packman in the current working dir)   [default: "./.packman"]
  -l, --logging  Logging level (only errors = 1, also warnings = 2, also info = 3, also debug = 4)  [default: 3]
  -h, --help     Displays this message                                                              [boolean]
  -w, --watch    Watch for file changes and run packman again if any                                [boolean]
</code></pre>

<p>As you can see, no option is mandatory. By default, packman will look for a file named <code>.packman</code> in the current directory.</p>

<p>Using the <code>watch</code> mode helps with productivity. It basically lets packman run and watch for file changes in the configured source directory so instead of having to manually run packman every time you make a change, your packages will be created after each and every file changed, automatically.</p>

<p>Config files are written in yaml and look like this</p>

<pre><code>source: my/source/dir
destination: my/target/dir
eraseIfExists: true
visitors:
    - coffeescript
    - jsmin
packages:
    main.js:
        files:
            - CORE.js
            - CORE/Object.js
            - CORE/Logging.js
    utils.js:
        files:
            includes:
                - CORE/utils/**/*.js
            excludes:
                - CORE/utils/specials/*.js
    css/styles.css:
        visitors:
            - less
        files:
            includes:
                - **/*.less
</code></pre>

<p>The first level of the config contains general configuration like the <code>source</code> and <code>destination</code> folders, a flag telling packman whether the destination should be erased if it already exists or not, the global <code>visitors</code> to use and the list of <code>packages</code> to create.</p>

<p>Many configuration parameters are optional, in fact, <code>packages</code> is really the one you want to work on. Here is the default config:</p>
<pre><code>source: ./src
destination: ./target
eraseIfExists: false
visitors:
    - sep
packages:
</code></pre>

<p>Then, inside the <code>packages</code> node, is the list of all packages to be created.</p>

<p>Files to be included inside a package are given in the <code>files</code> sub-node and can be either an array of file names, or an object with either <code>includes</code> or <code>excludes</code> or both. These sub-properties are arrays of file names or ant pattern (?, *, **). If an array of files is provided, the files will be merged in this order.</p>

<h1>Visitors</h1>

<p>You may have noticed that the configuration accepts a visitors array. A visitor is a piece of code that transform package content, package name and file content while things are done. This is the way to get packages perfectly fit to your needs.</p>

<p>You can imagine using visitors for pretty much anything you want. Visitors can alter the file content but also package file names and locations or simply output other files.</p>

<p>Examples of visitors include (but are not restricted to) including separators between the files, minifying file content, renaming package files to include a version number, processing less css or coffeescript files.</p>

<p>packman comes with a bunch of built-in visitors:</p>
<ul>
  <li><strong>sep</strong>: to separate content of different files inside a package (simply adding comment headers)</li>
  <li><strong>coffeescript</strong>: compile to JS any *.coffee file</li>
  <li><strong>less</strong>: compile to CSS any *.less file</li>
  <li><strong>uglify</strong>: minify and mangle JS content to make it smaller</li>
</ul>

<h2>Using visitors</h2>

<p>Visitors can be specified either globally at the top level of the config file, or locally, within each package definition. Visitors are configure through an array, and are, therefore, run in a sequence, one after the other.</p>

<p>Visitors specified simply by name (e.g. "less") is assumed to be a built-in visitor. If you want to use a visitor that is not provided by packman by default, specify the full (relative or absolute) path to the js file.</p>

<h2>Developing visitors</h2>

<p>A visitor in packman is simply a nodejs module that exports any of the following functions:</p>

<pre><code>// At the very start, just after the config file is loaded
onAfterConfigLoaded: function(callback, config) {},

// Main entry point, before any file is packaged
onStart: function(callback, config) {},

// Before starting to package a set of files together
onPackageStart: function(callback, config, packageFileObject) {},

// Before a file is being inserted into a package
onFileStart: function(callback, config, packageFileObject) {},

// When inserting the content of a file into a package
onFileContent: function(callback, config, fileObject) {},

// After a file has been inserted into a package
onFileEnd: function(callback, config, packageFileObject) {},

// After having packaged a set of files together
onPackageEnd: function(callback, config, packageFileObject) {},

// At the end, when all packages are done
onEnd: function(callback, config) {}
</code></pre>

<p>Visitors' methods can be asynchronous if needed, this is why they accept a callback as their first parameter. Once their processing is done, they must call the callback to allow packman to continue looping on other visitors, and ultimately on other files and packages.</p>

<p>Note that since the config is passed as argument to the above methods, you can add extra data to it to be used by visitors.</p>

<p>Most visitors' methods accept a <code>packageFileObject</code> as argument while the <code>onFileContent</code> method accepts a <code>fileObject</code> argument, here are their interfaces:</p>

<pre><code>PackageFile = {
    path: "the logical path of the package file",
    content: "the current content of the package file",
    currentFile: "reference to the File instance that is currently being packaged if any"
};

File =  {
    path: "the logical path of the file",
    physicalPath: "the physical path of the file",
    content: "the current content of the file",
    packageFile: "reference to the PackageFile including this file"
};
</code></pre>

<p>Most visitors will want to modify the fileObject.content on the fly (to minify javascript for instance) or to append content to the packageFileObject.content (to insert separators for instance).</p>

<h1>Special configuration parameters</h1>

<p>A couple of other parameters are more seldomly used but could be interesting to you</p>
<ul>
  <li>`eraseIfExists`: by default, packman won't delete the content of your target directory, pass this to true if you want it to</li>
  <li>`exitOnFailedVisitor`: turned off by default, turn it on if you want the packman process to exit with status code 1 when a visitor crashes</li>
  <li>`exitOnFileNotFound`: turned off by default, turn it on if you want the packman process to exit with status code 1 as soon as it finds a non existing file in the package configuration.</li>
</ul>

      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/captainbrosset">captainbrosset</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>